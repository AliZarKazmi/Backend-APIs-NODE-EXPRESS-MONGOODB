# Project Summary and Key Points:
1. JWT Basics
2. Authentication 
3. Authorization
4. Restricted Routes (these are like private routes which are accessed by those who has the correct Signed JWT)
5. Request Validation i.e Username and Password
6. Token-Based Authentication
7. Bearer Token
8. if the user provide the correct token then we allow them access.
9. VERIFYING THE TOKEN VALIDATION
10. Auth Middleware Setup

# Note: 
There are 3 ways for server side validation   (these all also ensure the "Data Intrigity ") 
1. Mongooose validation
2. Joi package 
3. checks in controller

# JWT (JSON Web Tokken):
JWT is just way to exchange data between two parties. This information can be verified and trusted because it is digitally signed.

# Working of JWT:
1. Client send creidentials -> Server accept and Response back with JWT
2. Next time client sent req with JWT -> Server first verify that token (JWt) then allow access or return response otherwise send error.
3. We store/send the token in Headers i.e "Authorization : Bearer ${token}"
4. On each request we always get different token if they provide the same credentials

# Then why Use JWT instead of random String => Because it has the "Security Feature" where can be sure about the integrity of our data 

# Types of Authentication:
1. Auth 2
2. Session
3. JWT (jwt.io)

# Resquest Status
400 -> Bad Req
401 -> Unauthorized
200 -> Ok
# Steps to create a jwt token:
1. Install jsonwebtoken npm module
2. Create an authentication middleware function that will check the username and password from req.body, compare it with the database and return the response accordingly
2. Create an express app
3. Import the middleware function from jsonwebtoken
4. Use this middleware function as a middelware on every route that needs authentication
5. If the token is valid, pass it to next() else return unauthorize status code
# How to use JsonWebToken?
1. import { sign } from 'jsonwebtoken'
2. const secret = process.env.JWT_SECRET || 'secret'; // you can set your own secret key here
3. sign(payload, secret, options);
- payload: data which will be stored inside the token
- secret: secret key used to generate the hashed signature
- options: optional object containing various properties like expiresIn
# What is Payload?
The information about the user that you want to include in the token. It could contain things like the users unique id or email address. The important thing
Payloads contain information about who the client is and what permissions they have. Itâ€™s important not to include sensitive information such as passwords or other secre
The information about the user that we want to store in the token. It could contain things like username, email or any other relevant info. The important
Payload contains information about the user who has been authenticated. It could contain any information related to the user. This information will be sent along with
Payloads contain information about the user who has been authenticated by the client. It contains details such as username or email address, password etc. The
The information about the user that the client sent when logging in. It contains the username and password. The server then uses these details to authenticate the
The information about user that should be included in the token. It could include things like username or id.
# What is Secret Key?
This is something that only the client knows and no one else has access to. This is what makes sure that the token is not tampered with
This is something that only the client and the server know. This is what makes sure that the tokens generated by the server cannot be tampered with
This is something that only server knows. This is not sent over network. The client never sees this.
# Options Object
It contains various settings for generating tokens. For example, how long the token should live before it expires.
{
    expiresIn: '2h', //expiry time for the token
    }
# How to verify Token?
1. import {verify} from 'jsonwebtoken'
2. const secret = process.env.JWT_SECRET || 'secret';
3. verify(token, secret, callbackFunction)
    - token: the token received from the client
    - secret: the secret key used to generate the hashed signature
    - callbackFunction: receives two arguments err and decoded
    if there is no error then decoded contains all the info from the payload
    otherwise err contains the error message
# How to protect routes with JWT?
1. Verify the token using the above method
2. Check if the token has been verified successfully by checking the value of req.decoded
if yes, proceed further
else send 401 status code back to the client
# How to handle errors while verifying tokens?
1. In case of any error during verification, we need to send a response back to the client indicating that the request was bad. We do
1. catch any error during verification
2. log the error
3. send 401 status code back to the client
